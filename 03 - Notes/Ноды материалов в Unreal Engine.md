>[!note]- **Landscape ноды**
> **LandscapeLayerBlend** - нода, которая собирает в себя слои материалов для лэндскейпа.  
> 
> **LandscapeLayerCoordinates** - аналог TexCoord, только для лэндскейпа. 

>[!note]- **Material Attributes ноды**
> **MakeMaterialAttributes** - создаёт материал из карт BaseColor, Roughness, Normal и тд.
> 
> **BlendMaterialAttributes** - аналог Lerp. Смешивает два материала по маске в альфа канале. 
> 
> **BreakMaterialAttributes** - позволяет разделить собранный материал, даёт аутпуты всех возможных карт. 
> 
> **GetMaterialAttributes** - позволяет вытащить определенные параметры из готового материала. Похож на BreakMaterialAttributes. 
> 
> **SetMaterialAttributes** - позволяет выбрать нужные параметры на инпут в материал. Похож на MakeMaterialAttributes. 
> 
> **MaterialAttributeLayers** - нода слоёв. Примерно то же самое, что и параметры, только под другим соусом.
  
>[!note]- **Математические ноды**  
> ==**Power**== - возведение в степень
> 
> ==**Add**== - сложение
> 
> ==**Subtract**== - вычитание
> 
> ==**Multiply**== - умножение
> 
> ==**Divide**== - деление
> 
> ==**Sine**== - синус. Выдаёт значения от -1 до 1.
> 
> ==**Cosine**== - косинус. Выдаёт значения от -1 до 1.
  
**Clamp** - отрезает значения по минимуму и максимуму
 
**Saturate** - то же самое, что Clamp, но не позволяет редактировать значения min и max. Но она сильно быстрее по производительности. Saturate при подключении в UV текстуры может блокировать ее тайлинг, если надо чтоб везде она тайлилась, а в определенном моменте нет.

**SplitComponents** - позволяет вытаскивать нужные каналы через аутпуты, аналог ноды Mask.

**AppendMany** - работает как обычный Append, но собирает в себя 4 канала: R, G, B, A

**Swizzle** - меняет местами каналы, принимает в себя XYZ или XY, выдаёт YXZ или YX.

**LinearInterpolate(Lerp)** - смешивает два значения по маске.

**If** - условие, как в программировании. Есть аналог - нода Step, которая стоит дешевле.

**Desaturate** - убирает цвет, делает изображение черно-белым

**Append** - создаёт вектор из чисел. Если подгрузить в него константу и вектор из двух чисел - получится вектор из трех чисел.

>[!note]- **TextureCoordinate(TexCoord)** - красно-зеленый градиент. При подключении в UV текстуры, позволяет задавать тайлинг. Coordinate Index выбирает нужную развертку. 
> ![[72 Untitled 7.png|72 Untitled 7.png]]
> Нода **Linear Gradient** - то же самое, что и TexCoord, но в виде функции. Не особо нужная, проще использовать TexCoord с масками.
    

**Custom Rotator** - нода для вращения текстуры. В Rotation Center подаём точку, относительно которой должно быть вращение, для центра плейна это например 0.5, 0.5. А в Rotation Angle - градус поворота.

**Rotator** - упрощенная версия Custom Rotator. Имеет только инпут Time, настройки вращения задаются в деталях ноды.

**Panner** - анимация сдвига по позиции X или Y. Имеет инпуты Time и Speed.

**OneMenus** - инверсия

>[!note]- **RadialGradientExponential** - радиальный градиент, в центре единица, по краям ноль.
> ![[44 Untitled 1 5.png|44 Untitled 1 5.png]] 

**DiamondGradient** - градиент в виде блика, звезды.

**FunctionOutput** - нужен для создания доп. аутпута у функции.

**FunctionInput** - нужен для создания инпута у функции.

**MaterialFunctionCall** - вызов нужной функции, в том числе и кастомной

**CollectionParameter** - вызов нужной коллекции, нужно например для того, чтобы поменять какой-то параметр у всех инстансов

**HueShift** - изменение оттенка по Hue. Подгружаем константу от 0 до 1 и саму текстуру.

**ScaleUVsByCenter** - скейл текстуры относительно центра. К ней подключается вектор двух чисел и получается аналог стандартной конструкции для тайлинга текстуры.

**Pi** - просто число Pi. На инпут имеет вход Multiplier.

**DebugScalarValues** - выдает числовой результат вычислений. Похожа на ноду Result в Xpresso.

**DebugFloat3Values** - выдает числовой результат вектора из трех чисел.

**Object Position** - позиция центра объекта в виде координат X, Y, Z.

**Object Radius** - радиус объекта.

**Actor Position** - позиция пивота объекта в виде координат X, Y, Z.

**ScreenPosition** - наложение текстуры относительно камеры. Если крутиться вокруг объекта, текстура всегда будет накладываться плоско. Подгружается в UVs текстуры.

**AbsoluteWorldPosition(**поиск по **WorldPosition)** - наложение текстуры относительно мировой позиции. При перемещении объекта, текстура тоже меняется. Можно выбирать с какой стороны накладывается текстура. Может использоваться для трипланарного наложения.

>[!note]- **WorldAlignedTexture** - заготовленный TriPlanar. Превращаем текстуру в Texture Object и подключаем в аналогичный инпут. Чтобы текстура была привязана к объекту - нужна конструкция из примечания.
> ![[56 Untitled 2 2.png|56 Untitled 2 2.png]]
 
>[!note]- **TransformPosition** - позволяет конвертировать мировые координаты в локальные и наоборот. В текущем примере используется вместо вычитания позиции актора из мировых координат.
> ![[63 Untitled 3 2.png|63 Untitled 3 2.png]]
 
>[!note]- **Pre-Skinned Local Position** - нода для того, чтобы трипланарный шейдер фиксировался на скелетной анимации. Подключается в WorldAlignedTexture через VertexInterpolator.
> ![[65 Untitled 4 2.png|65 Untitled 4 2.png]]

**Time** - используется для анимации в шейдере. Аналогичная нода есть в Xpresso. Задавая Period можно перезапускать цикл.

**Floor** - округление до целой части в меньшую сторону.

**Ceil** - округление до целой части в большую сторону.

**Frac** - отсекает целую часть, оставляет только дробную.

**BoundingBoxBased_0-1_UVW** - градиент от 0 до 1 по баунд боксу объекта, не опираясь на развертку объекта.

**SubUV_Function** - принимает в себя спрайт. Отличие от флипбука в том, что если подать анимацию тайма в Frame - перетекание анимации будет плавным по опасити.

**Flipbook** - нода аналогичная SubUV_Function, но еще позволяет делать жесткую анимацию спрайта.

**CurveAtlasRowParameter** - использование кривых из созданных атласов в материале.

>[!note]- **VertexNormalWS** - вертексные нормали объекта. С помощью этой ноды можно либо делать анимация смещения по нормалям, либо делать напыление сверху объекта.
> ![[67 Untitled 5 2.png|67 Untitled 5 2.png]]

>[!note]- **PixelNormalWS** - пиксельные нормали объекта. Если например нужно, чтобы снег, который лежит по вертексам учитывал еще и нормалки - нужно через Add смешать VertexNormalWS и PixelNormalWS.
> ![[69 Untitled 6 2.png|69 Untitled 6 2.png]]

**TransformVector(Transform)** - позволяет конвертировать мировой вектор в локальный и наоборот.

**VertexInterpolate** - интерполирует информацию из вертекс шейдера в пиксель шейдер.

>[!note]- **VectorToRadialValue** - полярные координаты. Анимация идёт из центра
> ![[71 Untitled 7 2.png|71 Untitled 7 2.png]]

**PerInstanceRandom** - рандом по каждому инстансу. Например, можно фолажем раскидать шарики, чтоб у каждого был рандомный цвет.

**Noise** - трехмерный нойз. Очень ресурсоемкий.

>[!note]- **Fresnel** - стандартный френель, как в РШ. Можно подставлять в стекло для реалистичности.
> ![[73 Untitled 8.png]]
> Бывает еще похожая на френель конструкция, которая считает вектор между камерой и поверхностью. В результате получает светлый ближе к камере, темный цвет по краям.
> ![[74 Untitled 9.png]] 

**FresnelFunction** - тот же френель, только с большим кол-вом настроек.

>[!note]- **PixelDepth** - показывает глубину пикселя, в зависимости от камеры. Отлично использовать например для частичек, чтоб они не были огромными при подлете к камере.
> ![[46 Untitled 10.png]]
 
>[!note]- **Camera Position** - показывает позицию камеры по X, Y, Z.
> ![[47 Untitled 11.png]]

**CameraVector** - вектор камеры относительно объекта.

**CameraDepthFade** - исчезание в зависимости от глубины.

**DistanceBlend** - исчезание в зависимости от расположения камеры.

>[!note]- **Distance** - показывает дистанцию между двумя точками или между двумя векторами. Текущий пример позволяет выбирать пипеткой нужный цвет и брать маску этого цвета, что позволяет использовать безграничное кол-во масок.
> ![[48 Untitled 12.png]]

>[!note]- **BumpOffset** - нода для подключения текстуры бампа. Подключаем в UVs всех остальных текстур.
> ![[49 Untitled 13.png]]
> ![[50 Untitled 14.png]]
 
>[!note]- **ParallaxOcclusionMapping** - продвинутое выдавливание, по типу нормалок. Сильно ресурсоемкий.
> ![[51 Untitled 15.png]]

**ChannelMaskParameter** - позволяет выбирать нужный канал из RGBA.

**StaticSwitch** - переключает между двумя условиями. В Value подаётся параметр Boole. Не считается в рантайме, может быть заменен на Lerp.

**StaticSwitchParameter** - то же самое, что и статик свич, но в неё уже вшита булева переменная. Не считается в рантайме, может быть заменен на Lerp.

**DepthFade** - работает только с Translucent материалом. Делает мягкий фейд при пересечении с объектом.

>[!note]- **DitherTemporalAA** - делает фейковую прозрачность в Masked режиме. Не особо качественно выглядит, для синематиков не особо нужен, тк используется чисто для повышения производительности.
 ![[52 Untitled 16.png]]
 
>[!note]- **ReflectionVector** - позволяет подмешать Cubemap в материал. С помощью нее можно добавить отражения в Translucent материал.
> ![[53 Untitled 17.png]]

**NormalFromHeightmap** - генерирует нормалку на основе хейтмапы. Выглядит хуже, чем оригинал, но тем не менее. И еще она довольно требовательна. Есть смысл использовать только если нужна нормалка в реалтайме, в ином случае лучше сделать ее в фотошопе.

>[!note]- **FlattenNormal** - нужна для регулирования силы нормалки. Но лучше использовать конструкцию представленную ниже, чтоб иметь доступ к параметрам.
> ![[54 Untitled 18.png]] 

**BlendAngleCorrectedNormals** - корректное смешивание нормалок.

**3ColorBlend** - смешивает 3 цвета по альфе. Если смешивать через Lerp - по центру будет некрасивый градиент. А это нода позволяет ему задать цвет

>[!note]- **TwoSidedSign** - нужна для того, чтобы по разному шейдить разные стороны объекта. С одной стороны выдает 1, с другой 0
> ![[55 Untitled 19.png]]

>[!note]- **SphereMask** - создаёт сферическую объемную 3D маску.
> ![[58 Untitled 20.png]] 

**SceneTexture** - используется в постпроцесс материалах. В Material Domain надо выбирать Post Process.

**VertexColor** - передаёт вертексную информацию с меша внутрь материала.

**Dot** - скалярное произведение двух векторов.

**Sign** - возвращает -1, если инпут меньше нуля, 1 если больше и 0 если 0. То есть по факту это округление в сторону большего.
